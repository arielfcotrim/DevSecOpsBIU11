# Git Basics (commit, diff, branches)

1. Done
2. Red
3. Red
4. Green
5. In step 2, the status was "new file: abc.txt" in red. Now it appears as "modified: abc.txt", also in red.
6. git diff
7. git diff
8. If all changes have already been committed / no change has been added to index, then there will be no difference to show.
9. Because of incorrect syntax (missing "--" and "2" isn't a file; also missing space between "stage" and "2".
10. Done
11. It prints nothing because there is no difference between the working tree and the index.
12. git diff-index main
13. Done
14. They would not. --staged shows what has been added to index that's different from main, "main" will show everything that's different from main.
15. Because the changes, "1" and "2", have been staged; whereas the change, "3", hasn't.
16. Done

# Resolve conflicts

1. git branch -a
2. git checkout -b feature/lambda_migration
3. git merge feature/version1
4. Done
5.
   1. Done
   2. Done
   3. Done
   4. Done
   5. Done
6. git rev-parse --abbrev-ref HEAD (to verify that I am on the correct branch), git status: "On branch feature/lambda_migration nothing to commit, working tree clean"

# Cherry picking

1. Done
2. Done
3.
    1. Done
    2. Done
4. .env and config.json
5. In general, we should always aim to maintain the logical flow of development. If we have a feature branch that is dependent on another feature branch, we should merge the dependent feature branch into the main branch first, and then merge the main branch into the feature branch. This way, we can avoid merge conflicts and keep the history of the project clean (for example).


# Changes in working tree and switch branches

1.Done
2. Done
3. git checkout dev
error: Your local changes to the following files would be overwritten by checkout:
        take.txt
**** Please commit your changes or stash them before you switch branches. ****
Aborting
4. Done
5. No
6. take.txt is not there. Force checkout throws away any uncommitted changes.

# Reset

1. Done
2.
   1. When using git reset --soft HEAD~1 you will remove the last commit from the current branch, but the file changes will stay in your working tree. Also the changes will stay on your index, so following with a git commit will create a commit with the exact same changes as the commit you "removed" before.
   2. When using git reset --mixed HEAD~1 you will remove the last commit from the current branch, but the file changes will stay in your working tree. Contrary to --soft, however, the changes will also be removed from the index ("unstaged").
   3. When using git reset --hard HEAD~1 you will lose all uncommited changes and all untracked files in addition to the changes introduced in the last commit. The changes won't stay in your working tree so doing a git status command will tell you that you don't have any changes in your repository.
   4. In order to revert the last Git commit, use the “git revert” and specify the commit to be reverted which is “HEAD” for the last commit of your history.
3. Git HEAD~1 means the previous commit of the last commit. Contrary to using the caret, git HEAD~ or HEAD with a tilde is simpler to understand as it references the previous commit of a specific branch. Another way to think about this is to go backward in a straightline.


# Working with GitHub

1.
2.
3.
4.
